<!DOCTYPE html>
<html lang="en">
<!-- <a title="Privacy-friendly Web Analytics" href="https://clicky.com/101459976"><img alt="Clicky" src="//static.getclicky.com/media/links/badge.gif" border="0" /></a> -->
<!-- Clicky webpage tracker service -->
<!-- <script async data-id="101459976" src="//static.getclicky.com/js"></script> -->

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARIADNE: A Graphical and Curated Resource Navigator</title>
  <link rel="icon" type="image/x-icon" href="ARIADNE_Logo.png">
  <style>
    :root {
        --screen-width: 0px;
        --screen-height: 0px;
    }
    #cy {
        width: var(--screen-width);
        height: var(--screen-height);
        position: relative;
        margin: 0 auto;
        left: 0;
        /* width: 80vw;
        height: 80vh; */
        /* position: absolute; */
        /* display: block; */
    }
    .custom-tooltip {
        font-family: Helvetica;
        position: absolute;
        background-color: #f1f1f1;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        z-index: 999; /* Ensure the tooltip appears above other elements */
    }
    .info-box {
        font-family: Helvetica;
        font-size: 15px;
        position: fixed;
        top: 10px;
        right: 10px;
        left: auto;
        width: 300px;
        background-color: #ffffff;
        border: 1px solid #cccccc;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.2);
        cursor: pointer;
        z-index: 9998;
    }
    .info-box.show {
        display: none;
    }
    /* Optimize list spacing inside info-box and key-box */
    .info-box ul,
    .key-box ul {
        margin: 5px 0;
        padding-left: 18px;
    }
    .info-box li,
    .key-box li {
        margin-bottom: 4px;
        line-height: 1.3;
    }
    #infoContent,
    #keyContent {
        margin: 0;
        padding: 0;
    }
    .info-box h2,
    .key-box h2 {
        margin: 0 0 5px 0;
        font-size: 16px;
    }
    .key-box {
        font-family: Helvetica;
        font-size: 15px;
        position: fixed;
        top: 120px;
        right: 10px;
        left: auto;
        width: 300px;
        background-color: #ffffff;
        border: 1px solid #cccccc;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.2);
        cursor: pointer;
        z-index: 9997;
    }
    .key-box.show {
        display: none;
    }
    body {
        margin: 0;
        padding: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('ARIADNE_Logo.png');
        background-size: 300px 300px;
        background-repeat: no-repeat;
        background-position: center center;
        /* position: relative; */
    }
    /* Shared button styles - positions now controlled by containers */
    .back-button,
    .osf-button,
    .glos-button {
        font-size: 15px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 16px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
        white-space: nowrap;
    }
    .back-button:hover,
    .osf-button:hover,
    .glos-button:hover {
        background-color: #45a049;
    }
    /* Suggestion & Bug buttons - positions now controlled by containers */
    .sugg-ghub-button,
    .sugg-gdrive-button,
    .bug-ghub-button,
    .bug-gdrive-button {
        font-size: 14px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 14px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
        white-space: nowrap;
    }
    .sugg-ghub-button:hover,
    .sugg-gdrive-button:hover,
    .bug-ghub-button:hover,
    .bug-gdrive-button:hover {
        background-color: #45a049;
    }
    /* .bullet-resource { list-style-type: disc; color: #D41159; } */

    /* ===== RESPONSIVE DESIGN ===== */
    
    /* Button containers for better organization */
    .nav-btn-container {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .bottom-btn-container {
        position: fixed;
        bottom: 10px;
        left: 10px;
        right: 10px;
        z-index: 9999;
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 8px;
        pointer-events: none;
    }
    
    .bottom-btn-container button {
        pointer-events: auto;
    }
    
    .bottom-left-group,
    .bottom-right-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
    }
    
    /* Common button base styles */
    .nav-btn-container button,
    .bottom-btn-container button {
        font-size: 14px;
        padding: 8px 14px;
        position: relative;
        top: auto;
        left: auto;
        right: auto;
        bottom: auto;
    }
    
    /* Medium screens (tablets) */
    @media (max-width: 900px) {
        .info-box {
            width: 220px;
            font-size: 13px;
            padding: 8px;
            right: 10px;
            left: auto;
            top: 10px;
        }
        
        .key-box {
            width: 220px;
            font-size: 13px;
            padding: 8px;
            right: 10px;
            left: auto;
            top: 110px;
        }
        
        .nav-btn-container button,
        .bottom-btn-container button {
            font-size: 13px;
            padding: 8px 12px;
        }

        body {
            background-size: 200px 200px;
        }
    }
    
    /* Mobile screens */
    @media (max-width: 600px) {
        .info-box {
            width: auto;
            max-width: 180px;
            font-size: 11px;
            padding: 6px;
            right: 5px;
            left: auto;
            top: 5px;
        }
        
        .key-box {
            width: auto;
            max-width: 180px;
            font-size: 11px;
            padding: 6px;
            right: 5px;
            left: auto;
            top: 80px;
        }
        
        .nav-btn-container {
            top: 5px;
            left: 5px;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            max-width: none;
        }
        
        .nav-btn-container button {
            font-size: 11px;
            padding: 5px 8px;
            width: auto;
        }
        
        .bottom-btn-container {
            flex-direction: column;
            align-items: stretch;
            bottom: 5px;
            left: 5px;
            right: 5px;
        }
        
        .bottom-left-group,
        .bottom-right-group {
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: flex-start;
            gap: 5px;
        }
        
        .bottom-btn-container button {
            font-size: 10px;
            padding: 6px 8px;
            flex: 1 1 auto;
            max-width: calc(50% - 5px);
        }
        
        .custom-tooltip {
            max-width: calc(100vw - 40px);
            font-size: 12px;
            padding: 8px;
        }

        body {
            background-size: 150px 150px;
        }
        
        #shapesCanvas {
            width: 100%;
            max-width: 200px;
            height: auto;
        }
    }
    
    /* Extra small screens */
    @media (max-width: 400px) {
        .nav-btn-container button {
            font-size: 10px;
            padding: 5px 6px;
        }
        
        .bottom-btn-container button {
            font-size: 9px;
            padding: 5px 6px;
        }
        
        .info-box, .key-box {
            font-size: 11px;
        }
    }
    
    /* Large screens */
    @media (min-width: 1200px) {
        .info-box, .key-box {
            font-size: 16px;
            width: 340px;
        }
        
        .info-box h2, .key-box h2 {
            font-size: 18px;
        }
        
        .nav-btn-container button {
            font-size: 16px;
            padding: 12px 18px;
        }
        
        .bottom-btn-container button {
            font-size: 15px;
            padding: 10px 16px;
        }
    }
  </style>
  <script src="./cytoscape/cytoscape.min.js"></script>
  
</head>
<body>
    <!-- Top-left navigation buttons -->
    <div class="nav-btn-container">
        <button id="back-button" class="back-button" title="For more information, see the ARIADNE book">← ARIADNE Book</button>
        <button id="osf-button" class="osf-button" title="Go to the OSF repository to see the complete resource table">← OSF Repository</button>
        <button id="glos-button" class="glos-button" title="Go to the Glossary of terms used">← Glossary</button>
    </div>
    
    <!-- Bottom action buttons -->
    <div class="bottom-btn-container">
        <div class="bottom-left-group">
            <button id="sugg-gdrive-button" class="sugg-gdrive-button" title="If you have a new resource to suggest; please report them to us via Google Forms!">+ Suggest new resource via Google Forms</button>
            <button id="sugg-ghub-button" class="sugg-ghub-button" title="If you have a new resource to suggest; please report them to us via GitHub issues!">+ Suggest new resource via GitHub</button>
        </div>
        <div class="bottom-right-group">
            <button id="bug-gdrive-button" class="bug-gdrive-button" title="If you have a bug that you have encountered; please report them to us via Google Forms!">Report a bug via Google Forms</button>
            <button id="bug-ghub-button" class="bug-ghub-button" title="If you have a bug that you have encountered; please report them to us via GitHub issues!">Report a bug via GitHub</button>
        </div>
    </div>
    
    <div id="cy"></div>
    <div id="info-box" class="info-box">
        <span id="infoTitle"><h2>Instructions:</h2> Click to hide/unhide the instructions</span>
        <div id="infoContent" hidden>
            <ul>
            <li>First things first. This is a "dynamic" network. This means that you can drag the nodes around and zoom in/out to resize the view</li>
            <li>Left click on a node to go to the next levels.</li>
            <li>Right click on anywhere to reset to the initial overview.</li>
            <li>Right click on a node to go back to the previous level in the network.</li>
            <li>Hover on any resource node to reveal the information regarding the node.</li>
            <li>Left click on the resource nodes to go to the respective webpages.</li>
            <li>Drag and drop on the nodes to rearrange the graph</li>
            <li>Here's the explanation of all the shapes, just hover over them to reveal the details:</li>
            <canvas id="shapesCanvas" width="280" height="140"></canvas>
        </div>
    </div>
    <div id="key-box" class="key-box" hidden>
        <span id="keyTitle"><h2>Key Questions:</h2> Click to hide/unhide the key questions</span>
        <div id="keyContent" hidden>
            <ul>
            <li></li>
        </div>
    </div>
    <script>
        // Get the canvas element
        var canvas = document.getElementById("shapesCanvas");
        var ctx = canvas.getContext("2d");

        // Define shapes and their respective popup messages
        var shapes = [
            { x: 0, y: 20, width: 40, height: 40, color: "#005AB5", rect: true, 
            popupMessage: "Initial node, there are more nodes inside this one!" },
            { x: 130, y: 40, radius: 20, color: "#D41159", 
            popupMessage: "Final node. Click this node to go to the resource's website!" }, 
            { x: 55, y: 20, width: 40, height: 40, color: "#40B0A6", diamond: true, 
            popupMessage: "Decision node, filter the nodes and move deeper!" },
            { 
                x: 0, y: 80, width: 35, height: 35, 
                src: "https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/graph/imgs/closed_lock_with_key.png", 
                popupMessage: "Hybrid (partially) open access resource!" 
            },
            { 
                x: 50, y: 80, width: 35, height: 35, 
                src: "https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/graph/imgs/lock.png", 
                popupMessage: "Fully closed access resource!" 
            },
            { 
                x: 100, y: 80, width: 35, height: 35, 
                src: "https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/graph/imgs/unlock.png", 
                popupMessage: "Fully open access resource!" 
            } 
        ];

        var loadedImages = [];
        var imagesToLoad = shapes.filter(shape => shape.src).length;
        var imagesLoaded = 0;

        // Preload images
        shapes.forEach(function(shape, index) {
            if (shape.src) {
                var img = new Image();
                img.src = shape.src;
                img.onload = function() {
                    loadedImages[index] = img;
                    imagesLoaded++;
                    if (imagesLoaded === imagesToLoad) {
                        drawShapes();
                    }
                };
            }
        });

        // Draw shapes on the canvas
        function drawShapes() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas completely
            shapes.forEach(function (shape, index) {
                if (shape.src && loadedImages[index]) {
                    ctx.drawImage(loadedImages[index], shape.x, shape.y, shape.width, shape.height);
                } else {
                    ctx.fillStyle = shape.color;
                    if (shape.radius) {
                        ctx.beginPath();
                        ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (shape.diamond) {
                        ctx.beginPath();
                        ctx.moveTo(shape.x + shape.width / 2, shape.y);
                        ctx.lineTo(shape.x + shape.width, shape.y + shape.height / 2);
                        ctx.lineTo(shape.x + shape.width / 2, shape.y + shape.height);
                        ctx.lineTo(shape.x, shape.y + shape.height / 2);
                        ctx.closePath();
                        ctx.fill();
                    } else if (shape.rect) {
                        ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                    }
                }
            });
        }

        // Function to show popup message
        function showPopup(message, x, y, c_width, c_height) {
            var padding = 10;
            ctx.font = '12px Arial';

            // Determine the maximum width for the popup (e.g., a percentage of the canvas width)
            var maxPopupWidth = Math.min(200, canvas.width - 5 * padding);
            // var maxPopupWidth = 500;

            // Split the message into lines if it exceeds the maximum width
            var words = message.split(' ');
            var lines = [];
            var currentLine = words[0];

            for (var i = 1; i < words.length; i++) {
                var testLine = currentLine + ' ' + words[i];
                var testWidth = ctx.measureText(testLine).width;
                if (testWidth > 100) {
                    lines.push(currentLine);
                    currentLine = words[i];
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine);

            // get the longest word to calculate the popup width
            function getLongestWord(wordList) {
                var longestWord = wordList.reduce(function(a, b) {
                    return a.length > b.length ? a : b;
                }, ""); // Find and return the longest word
                
                return longestWord;
            }
            var longestWord = getLongestWord(lines);

            // Calculate the height of the popup based on the number of lines
            var lineHeight = 20;
            var popupHeight = lineHeight * lines.length;
            var popupWidth = Math.min(ctx.measureText(longestWord).width + 2 * padding, maxPopupWidth);

            // Calculate popup position based on mouse position
            var popupX = x;
            var popupY = y - popupHeight - padding;

            // Adjust popup position to stay within canvas bounds
            if (popupX + popupWidth > canvas.width) {
                popupX = canvas.width - popupWidth - padding;
            }
            if (popupY < 0) {
                popupY = y + padding;
            }

            // Clear the canvas and redraw shapes
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawShapes();

            // Draw the popup background
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
            ctx.fillRect(popupX, popupY, popupWidth, popupHeight);

            // Draw the popup text line by line
            ctx.fillStyle = "black";
            lines.forEach((line, index) => {
                ctx.fillText(line, popupX + padding, popupY + padding + (index * lineHeight));
            });
        }

        // Event listener for mouse movement
        canvas.addEventListener('mousemove', function (e) {
            var mouseX = e.offsetX;
            var mouseY = e.offsetY;
            var popupShown = false;

            // Iterate through the shapes to detect if the mouse is over any shape
            shapes.forEach(function (shape) {
                if (shape.radius) {
                    var dx = mouseX - shape.x;
                    var dy = mouseY - shape.y;
                    var distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance <= shape.radius) {
                        // Show popup for circular shapes
                        showPopup(shape.popupMessage, mouseX, mouseY, canvas.width, canvas.height);
                        popupShown = true;
                    }
                } else {
                    if (mouseX >= shape.x && mouseX <= shape.x + shape.width &&
                        mouseY >= shape.y && mouseY <= shape.y + shape.height) {
                        // Show popup for rectangular shapes
                        showPopup(shape.popupMessage, mouseX, mouseY, canvas.width, canvas.height);
                        popupShown = true;
                    }
                }
            });

            // If no popup is shown, clear the popup area only
            if (!popupShown) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawShapes();
            }
        });

        // Event listener to clear popup when mouse leaves the canvas
        canvas.addEventListener("mouseleave", function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawShapes();
});
</script>



  <script>
        // Get the width and height of the screen - responsive calculation
        function updateScreenDimensions() {
            var screenWidth = window.innerWidth;
            var screenHeight = window.innerHeight;
            
            // Responsive width and height calculation based on screen size
            // All sizes use centered layout with auto margins
            var graphWidth, graphHeight;
            if (screenWidth <= 600) {
                // Mobile: use more screen space, reduce height for buttons
                graphWidth = screenWidth * 0.95;
                graphHeight = screenHeight * 0.70; // Leave room for top nav and bottom buttons
            } else if (screenWidth <= 900) {
                // Tablet: moderate margins
                graphWidth = screenWidth * 0.90;
                graphHeight = screenHeight * 0.80;
            } else {
                // Desktop: centered layout
                graphWidth = screenWidth * 0.85;
                graphHeight = screenHeight * 0.90;
            }
            
            // Set CSS variables with screen dimensions
            document.documentElement.style.setProperty('--screen-width', graphWidth + 'px');
            document.documentElement.style.setProperty('--screen-height', graphHeight + 'px');
            
            // Update graph container position - centered with auto margins
            var cyContainer = document.getElementById('cy');
            if (cyContainer) {
                cyContainer.style.left = '0';
                cyContainer.style.margin = '0 auto';
            }
            
            return { screenWidth, screenHeight, graphWidth, graphHeight };
        }
        
        // Initial call
        var dims = updateScreenDimensions();
        var screenWidth = dims.screenWidth;
        var screenHeight = dims.screenHeight;
        
        // Also the size of the info box
        function updateInfoBoxSize() {
            dims = updateScreenDimensions();
            screenWidth = dims.screenWidth;
            var infoBox = document.getElementById('info-box');
            var keyBox = document.getElementById('key-box');
            
            // Adjust the width and position of boxes based on screen width
            if (screenWidth <= 600) {
                // Mobile: smaller width, positioned on right to avoid nav buttons
                infoBox.style.width = 'auto';
                infoBox.style.maxWidth = '180px';
                infoBox.style.right = '5px';
                infoBox.style.left = 'auto';
                if (keyBox) {
                    keyBox.style.width = 'auto';
                    keyBox.style.maxWidth = '180px';
                    keyBox.style.right = '5px';
                    keyBox.style.left = 'auto';
                }
            } else if (screenWidth <= 900) {
                // Tablet: moderate width
                infoBox.style.width = '220px';
                infoBox.style.maxWidth = '';
                infoBox.style.right = '10px';
                infoBox.style.left = 'auto';
                if (keyBox) {
                    keyBox.style.width = '220px';
                    keyBox.style.maxWidth = '';
                    keyBox.style.right = '10px';
                    keyBox.style.left = 'auto';
                }
            } else {
                // Desktop
                infoBox.style.width = '300px';
                infoBox.style.maxWidth = '';
                infoBox.style.right = '10px';
                infoBox.style.left = 'auto';
                if (keyBox) {
                    keyBox.style.width = '300px';
                    keyBox.style.maxWidth = '';
                    keyBox.style.right = '10px';
                    keyBox.style.left = 'auto';
                }
            }
        }
        // Call the function when the window is resized
        window.addEventListener('resize', updateInfoBoxSize);
        // Get the button element
        var redirectToMainButton = document.getElementById('back-button');
        // Add a click event listener to the button
        redirectToMainButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://igor-biodgps.github.io/ARIADNE/contentpages/intro.html', '_blank');
            // window.location.href = 'https://igor-biodgps.github.io/ARIADNE/contentpages/intro.html';
        });
        // jump to osf button
        var redirectToOsfButton = document.getElementById('osf-button');
        // Add a click event listener to the button
        redirectToOsfButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://osf.io/tqjh8/', '_blank');
            // window.location.href = 'https://osf.io/tqjh8/'; 
        });
        // jump to glossary button
        var redirectToGlosButton = document.getElementById('glos-button');
        // Add a click event listener to the button
        redirectToGlosButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://igor-biodgps.github.io/ARIADNE/contentpages/Glossary.html', '_blank'); 
            // window.location.href = 'https://osf.io/tqjh8/';
        });
        // suggestion buttons
        // Get the button element
        var redirectGhubButton = document.getElementById('sugg-ghub-button');
        // Add a click event listener to the button
        redirectGhubButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://github.com/IGOR-bioDGPs/ARIADNE/issues/new?assignees=&labels=new+resource&projects=&template=resource-submission-form.md&title=', '_blank');
        });
        // Get the button element
        var redirectGDriveButton = document.getElementById('sugg-gdrive-button');
        // Add a click event listener to the button
        redirectGDriveButton.addEventListener('click', function() {
            // Open the desired webpage in a new tab
            window.open('https://docs.google.com/forms/d/1Xqk6MyLYvjdu9cbs1-R40hn9mIZ6KtKL-4LcpI80I_I/', '_blank');
        });
        // now the bug report buttons
        // Get the button element
        var redirectGhubButton = document.getElementById('bug-ghub-button');
        // Add a click event listener to the button
        redirectGhubButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://github.com/IGOR-bioDGPs/ARIADNE/issues/new?assignees=&labels=&projects=&template=bug_report.md&title=', '_blank');
        });
        // Get the button element
        var redirectGDriveButton = document.getElementById('bug-gdrive-button');
        // Add a click event listener to the button
        redirectGDriveButton.addEventListener('click', function() {
            // Open the desired webpage in a new tab
            window.open('https://docs.google.com/forms/d/1sCcvmlokUuWc4EG5mz0vXx-QRkyfqN69ibK5b3PqArA/', '_blank');
        });
        // Add a click event listener to the info-box
        var infoBox = document.getElementById('info-box');
        var infoContent = document.getElementById('infoContent');
        infoBox.addEventListener('click', function() {
            infoContent.toggleAttribute("hidden");
            // infoContent.style.zIndex = -1; // when clicked draw it in the most highest z-level
            // keyContent.style.zIndex = 1; // when clicked draw it in the most highest z-level
            // keyContent.css('z-index', 1);
            keyContent.style.zIndex = 1;
            // infoContent.css('z-index', 200);
            infoContent.style.zIndex = 200;
        });
        // Add a click event listener to the key-box
        var keyBox = document.getElementById('key-box');
        var keyContent = document.getElementById('keyContent');
        keyBox.addEventListener('click', function() {
            keyContent.toggleAttribute("hidden");
            // keyContent.style.zIndex = -1; // when clicked draw it in the most highest z-level
            // infoContent.style.zIndex = 1; // when clicked draw it in the most highest z-level
            // keyContent.css('z-index', 200);
            keyContent.style.zIndex = 200;
            // infoContent.css('z-index', 1);
            infoContent.style.zIndex = 1;
        });
    </script>
    <script>
        // async function to get nodes (local OR GitHub)
        async function fetchDataNodes() {
        try {
            // Auto-detect: use local if running on localhost, otherwise use GitHub
            const isLocal = window.location.hostname === 'localhost' || 
                        window.location.hostname === '127.0.0.1' ||
                        window.location.protocol === 'file:';
            
            const githubRawURL = 'https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/ariadne/data/data_ariadne_nodes.csv';
            const localURL = '../ariadne/data/data_ariadne_nodes.csv';
            
            const dataURL = isLocal ? localURL : githubRawURL;
            
            console.log('Environment:', isLocal ? 'Local' : 'GitHub', '- Fetching from:', dataURL);
            const response = await fetch(dataURL);
            const csvData = await response.text();
            const rows = csvData.split('\n');

            function clean(v) {
            return (v === "NA" || v === "" || v === undefined) ? null : v;
            }

            const nodes = rows.map(row => {  
            const [  
                id, label, shape, bgColor, fontColor, rank,  
                subgraph, subgraphDet, mainGraph, isTerminal,  
                href, tooltip, descr, openSource, keyQuestions,  
                keyLink, path  
            ] = row.split(';');  
    
            return {  
                data: {  
                id: clean(id),  
                label: clean(label),  
                shape: clean(shape),  
                background_color: clean(bgColor),  
                font_color: clean(fontColor),  
                rank: clean(rank),  
                subgraph: clean(subgraph),  
                subgraphDet: clean(subgraphDet),  
                mainGraph: clean(mainGraph),  
                is_terminal: clean(isTerminal),  
                href: clean(href),  
                tooltip: clean(tooltip),  
                descr: clean(descr),  
                openSource: clean(openSource),  
                keyQuestions: clean(keyQuestions),  
                keyLink: clean(keyLink),  
                path: clean(path),  
                }  
            };  
            });

            return { nodes };
        } catch (err) {
            console.error('Error fetching nodes CSV:', err);
            return null;
        }
        }
        // async function to get edges (local OR GitHub)
        async function fetchDataEdges() {
        try {
            // Auto-detect: use local if running on localhost, otherwise use GitHub
            const isLocal = window.location.hostname === 'localhost' || 
                        window.location.hostname === '127.0.0.1' ||
                        window.location.protocol === 'file:' ||
                        window.location.hostname === "[::1]";
            
            const githubRawURL = 'https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/ariadne/data/data_ariadne_edges.csv';
            const localURL = '../ariadne/data/data_ariadne_edges.csv';
            
            const dataURL = isLocal ? localURL : githubRawURL;
            
            console.log('Environment:', isLocal ? 'Local' : 'GitHub', '- Fetching from:', dataURL);
            const response = await fetch(dataURL);
            const csvData = await response.text();
            const rows = csvData.split('\n');

            function clean(v) {
            return (v === "NA" || v === "" || v === undefined) ? null : v;
            }

            const edges = rows.map(row => {  
            const [id, source, target, subgraph, label, bgColor] = row.split(';');  
            return {  
                data: {  
                id: clean(id),  
                source: clean(source),  
                target: clean(target),  
                subgraph: clean(subgraph),  
                label: clean(label),  
                background_color: clean(bgColor),  
                }  
            };  
            });

            return { edges };
        } catch (err) {
            console.error('Error fetching edges CSV:', err);
            return null;
        }
        }
        // index variable for keeping track of the first run or others
        let index = 0;
        // get previous subgraph
        let graphPathArr = [];
        // Global reference to current Cytoscape instance for resize handling
        let cyInstance = null;
        
        // Helper function to get responsive font size
        function getResponsiveFontSize() {
            var width = window.innerWidth;
            if (width <= 400) return 14;
            if (width <= 600) return 16;
            if (width <= 900) return 20;
            return 24;
        }
        
        // Debounce helper to avoid excessive updates
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Window resize handler for Cytoscape
        window.addEventListener('resize', debounce(function() {
            // Update CSS variables for graph container size
            updateScreenDimensions();
            updateInfoBoxSize();
            
            if (cyInstance) {
                // Update node and edge styles based on new screen size
                const nodeFontSize = getResponsiveFontSize();
                const edgeFontSize = Math.max(12, nodeFontSize - 4);
                const textMaxWidth = window.innerWidth <= 600 ? 100 : 150;
                const edgeTextMaxWidth = window.innerWidth <= 600 ? 60 : 100;
                
                // Apply updated styles
                cyInstance.style()
                    .selector('node')
                    .style({
                        'font-size': nodeFontSize,
                        'text-max-width': textMaxWidth
                    })
                    .selector('edge')
                    .style({
                        'font-size': edgeFontSize,
                        'text-max-width': edgeTextMaxWidth
                    })
                    .update();
                
                // Resize container and fit graph
                cyInstance.resize();
                cyInstance.fit();
            }
        }, 150));
        
        // async function to create and draw the graph
        async function createNetwork(sub_graph = '') {
            // wait for nodes
            const nodesArrayAux = await fetchDataNodes();
            // wait for edges
            const edgesArrayAux = await fetchDataEdges();
            // assign nodes&edges to respective variables
            const nodesArray = nodesArrayAux.nodes;
            const edgesArray = edgesArrayAux.edges;
            // Validate and sanitize IDs in the nodesArray
            nodesArray.forEach(node => {
            if (typeof node.data.id !== 'string' || !node.data.id.trim()) {
                // If the ID is not a valid string or is empty, generate a unique ID
                node.data.id = 'node_' + Math.random().toString(36).substr(2, 9);
            }
            });
            // Validate and sanitize IDs in the edgesArray
            edgesArray.forEach(edge => {
            if (typeof edge.data.id !== 'string' || !edge.data.id.trim()) {
                // If the ID is not a valid string or is empty, generate a unique ID
                edge.data.id = 'node_' + Math.random().toString(36).substr(2, 9);
            }
            });
            graphPathArr.push(sub_graph);
            // filter the nodes&edges wrt. to selected node's subgraph
            const filteredNodes = nodesArray.filter(item => item.data?.subgraph?.toLowerCase() === sub_graph?.toLowerCase());
            const filteredEdges = edgesArray.filter(item => item.data?.subgraph?.toLowerCase() === sub_graph?.toLowerCase());
            // now combine the arrays
            const filteredAll = filteredNodes.concat(filteredEdges);
            // Get responsive font size
            const nodeFontSize = getResponsiveFontSize();
            const edgeFontSize = Math.max(12, nodeFontSize - 4);
                // configure the cytoscape graph here
                const cy = cytoscape({
                    container: document.getElementById('cy'), // will be drawn on div tag 'cy'
                    elements: filteredAll, // only the filtered elements
                    style: [ // now construct the style of the nodes and edges from the filtered variables
                        {
                        selector: 'node', // node style
                        style: {
                            'background-color': 'data(background_color)',
                            'shape': 'data(shape)',
                            'label': 'data(label)',
                            'font-size': nodeFontSize,
                            'text-wrap': 'wrap', // or 'ellipsis' for truncation
                            'text-max-width': window.innerWidth <= 600 ? 100 : 150, // Responsive text width
                            'background-width': '80%', // those four variables fix the position of the images
                            'background-height': '80%', // those four variables fix the position of the images
                            'background-offset-x' : '140%', // those four variables fix the position of the images
                            'background-offset-y' : '140%', // those four variables fix the position of the images
                            'background-clip' : 'none', // no clipping
                            'background-image-containment': 'over', // draw the image over the node
                            'bounds-expansion': 4 // expand the bounding box
                        }
                        },
                        { // testing to production: change /dev/ to master
                            selector: 'node[openSource= "TRUE"]',
                            style: {
                            'background-image': 'url(https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/graph/imgs/unlock.png)'
                            }
                        },
                        {
                            selector: 'node[openSource= "HYBRID"]',
                            style: {
                            'background-image': 'url(https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/graph/imgs/closed_lock_with_key.png)'
                            }
                        },
                        {
                            selector: 'node[openSource= "FALSE"]',
                            style: {
                            'background-image': 'url(https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/graph/imgs/lock.png)'
                            }
                        },
                        {
                        selector: 'edge', // edge style
                        style: {
                            'width': 2,
                            'font-size': edgeFontSize,
                            'line-color': '#ccc',
                            'target-arrow-color': '#ccc',
                            'target-arrow-shape': 'triangle',
                            'text-wrap': 'wrap',
                            'text-max-width': window.innerWidth <= 600 ? 60 : 100,
                            'text-wrap': 'wrap',
                            'label': 'data(label)'
                        }
                        }
                    ],
                    layout: { // layout is circular
                        name: 'circle',
                        fit: true, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                    },
                    zoom: 1
                });
                if (sub_graph != 'initial'){ 
                    var styleOptions = cy.layout({
                        name: 'circle',
                        fit: true, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                        // avoidOverlapPadding: 20, // extra spacing around nodes when avoidOverlap: true
                        spacingFactor: 1.5,
                    });
                    styleOptions.run();
                }
                if (filteredNodes.length < 3){
                    // Calculate the center of the screen
                    var centerX = screenWidth / 2;
                    var centerY = window.innerHeight / 2;

                    // Calculate the positions for the nodes
                    var positions = {};
                    positions[filteredNodes[0].data.id] = { x: centerX - 175, y: centerY - 200 };
                    positions[filteredNodes[1].data.id] = { x: centerX - 175, y: centerY + 50 };

                    // Define layout options
                    var styleOptions2 = cy.layout({
                        name: 'preset',
                        fit: false, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                        // avoidOverlapPadding: 20, // extra spacing around nodes when avoidOverlap: true
                        // spacingFactor: 1,
                        zoom: 0.88,
                        // pan: { x: centerX, y: centerY },
                        positions: positions // Assign positions for nodes
                    });
                    styleOptions2.run();
                } else if(filteredNodes.length >= 3 && filteredNodes.length < 7){ // breadthfirst if less than 7 nodes, else circular
                    var styleOptions = cy.layout({
                        name: 'breadthfirst',
                        grid:false,
                        fit: true, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                        // avoidOverlapPadding: 20, // extra spacing around nodes when avoidOverlap: true
                        spacingFactor: 1.5,
                    });
                    styleOptions.run();
                } else {
                    var styleOptions = cy.layout({
                        name: 'circle',
                        fit: true, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                        // avoidOverlapPadding: 20, // extra spacing around nodes when avoidOverlap: true
                        spacingFactor: 1.5,
                    });
                    styleOptions.run();
                }
                // Store reference to current cy instance for resize handling
                cyInstance = cy;
                main(index, cy, graphPathArr); // and now call the main function so we run it indefinitely
                index += 1; // increase the index because we run the code once already
                // in the next block, keybox is set
                var keyBox = document.getElementById('key-box');
                if (sub_graph !== 'initial'){
                    if (keyBox.hasAttribute('hidden')) {
                    // If it is set, remove the attribute to show the element
                        keyBox.removeAttribute('hidden');
                    } 
                }else {
                    // If it is not set, add the attribute to hide the element
                    keyBox.setAttribute('hidden', '');
                }
        }
        // main function
        async function main(index, cyto, graphPathArr) {
            const minZoom = 0.6; // minimum allowed zoom level
            const maxZoom = 1.2; // maximum allowed zoom level
            // get cyto .css element first
            var cytoCSS = document.body;
            if (index == 0){ // if it's the first iteration
                cyto = await createNetwork('initial'); // draw the initial overview
            }
            else{ // if it's not the first iteration
                // if there is a left click on a node
                cyto.on('click', 'node', function(event) {
                    cytoCSS.style.backgroundImage = 'url("")'; // remove background image
                    var node = event.target; // get the node
                    if (node.data('is_terminal') == 'no'){ // if it's not a terminal node
                        createNetwork(node.data('id').replaceAll(' ','')); // and give it to the network function as 'subgraph'
                        if (node.data('mainGraph') == 'initial'){ // only if it's an initial node we should show the key questions
                            updateKeyContent(node, 'left_click'); // Call the function to update key content
                        }
                    }
                    else{ // if it's a terminal node
                        window.open(node.data('tooltip'), '_blank'); // redirect to the respective webpage
                    }
                });
                // if there is a right click anywhere
                cyto.on('cxttap', function(event) {
                    try { // check if a node is clicked, or anywhere else
                        var isNode = event.target.isNode(); // a variable that checks if a node is clicked
                    } catch (error){
                        var isNode = false;
                    }
                    cytoCSS.style.backgroundImage = 'url("ARIADNE_Logo.png")'; // add background image
                    const tooltips = document.querySelectorAll('.custom-tooltip'); // get all tooltips, i.e. boxes
                    tooltips.forEach(tooltip => tooltip.remove()); // and remove all of them
                    createNetwork('initial'); // and reset to the initial overview
                    if (!isNode) { // only reset if the reset screen right click appears
                        updateKeyContent('', 'right_click'); // Call the function to update key content
                    }
                    cyto.zoom(minZoom); // set zoom to the minimum value
                });
                // if there is a right click on a node
                cyto.on('cxttap', 'node', function(event) {
                    const node = event.target;
                    var auxElem = graphPathArr[index-1]; // get the previous subgraph
                    if (auxElem != 'initial'){
                        cytoCSS.style.backgroundImage = 'url("")'; // add background image
                    } else if (auxElem == 'initial'){
                        updateKeyContent('', 'right_click'); // Call the function to update key content
                    }
                    createNetwork(auxElem.replace(' ','')); // and reset to the initial overview
                });
                // if there mouse is on a node
                cyto.on('mouseover', 'node', function(event) {
                    const node = event.target;
                    if (node.data('is_terminal') == 'yes'){ // and it's a terminal node
                        var tooltip = document.createElement('div'); // create a tooltip div tag
                        tooltip.className = 'custom-tooltip'; // using the respective CSS 
                        tooltip.textContent = node.data('descr'); // and show the descriptions of the nodes
                        document.body.appendChild(tooltip); // and append to the div tag created
                        // Position the tooltip relative to the node's position and dimensions
                        const nodePosition = node.renderedPosition(); // node's position
                        const nodeHeight = node.height(); // node's height
                        const nodeWidth = node.width(); // node's width
                        tooltip.style.left = nodePosition.x + 'px'; // distance from left
                        tooltip.style.top = nodePosition.y + nodeHeight + 10 + 'px'; // distance from top
                    }
                });
                // if the mouse is moved outside of a node
                cyto.on('mouseout', 'node', function() {
                    const tooltips = document.querySelectorAll('.custom-tooltip'); // get all the boxes
                    tooltips.forEach(tooltip => tooltip.remove()); // and remove them
                });
                // also we want to lock the amount of zoom
                cyto.on('zoom', function(event) { // handle the zooming part
                    const currentZoom = cyto.zoom();
                    // limit the zoom level to the specified range
                    if (currentZoom < minZoom) {
                        cyto.zoom(minZoom); // set zoom to the minimum value
                    } else if (currentZoom > maxZoom) {
                        cyto.zoom(maxZoom); // set zoom to the maximum value
                    }
                    cyto.center(); // center the whole graph to viewport 
                });
            }
        }
        function updateKeyContent(node, clickType) {
            const keyContent = document.getElementById('keyContent');
            keyContent.innerHTML = '\n'; // Clear previous content
            if (clickType == 'left_click') {
                // Add new content based on the node's key questions
                const keyQuestions = node.data('keyQuestions').split('||'); // Split the string into an array
                ul = document.createElement('ul');
                ul.style.listStylePosition = 'outside';
                keyContent.appendChild(ul);
                keyQuestions.forEach(question => {
                    const newKey = document.createElement('li');
                    newKey.textContent = question.trim(); // Trim any extra spaces
                    ul.appendChild(newKey);
                });
                // add the keyLink
                ul = document.createElement('ul');
                ul.style.listStylePosition = 'outside';
                keyContent.appendChild(ul);
                const newKeyLink = document.createElement('a');
                // Set the href attribute
                newKeyLink.href = node.data('keyLink');
                newKeyLink.target = '_blank';
                // Create a text node with the content of keyLink and add it to the newKeyLink
                newKeyLink.textContent = "Click here to read the step description";
                // Append the newKeyLink to the keyContent
                keyContent.appendChild(newKeyLink);

            } else if (clickType == 'right_node_click'){ // if right click is on node
                // Add new content based on the node's key questions
                const keyQuestions = node.data('keyQuestions').split('||'); // Split the string into an array
                ul = document.createElement('ul');
                ul.style.listStylePosition = 'outside';
                keyContent.appendChild(ul);
                keyQuestions.forEach(question => {
                    const newKey = document.createElement('li');
                    newKey.textContent = question.trim(); // Trim any extra spaces
                    ul.appendChild(newKey);
                });
                // add the keyLink
                ul = document.createElement('ul');
                ul.style.listStylePosition = 'outside';
                keyContent.appendChild(ul);
                const newKeyLink = document.createElement('a');
                // Set the href attribute
                newKeyLink.href = node.data('keyLink');
                newKeyLink.target = '_blank';
                // Create a text node with the content of keyLink and add it to the newKeyLink
                newKeyLink.textContent = "Click here to read the step description";
                // Append the newKeyLink to the keyContent
                keyContent.appendChild(newKeyLink);
            }
            else if (clickType == 'right_click'){
                // Reset to initial view
                const newKey = document.createElement('li');
                newKey.textContent = `Initial view`;
                keyContent.appendChild(newKey);
            }
        }
        main(index);
  </script>
</body>
</html>
