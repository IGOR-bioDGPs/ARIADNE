<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ARIADNE: A Graphical and Curated Resource Navigator</title>
  <link rel="icon" type="image/x-icon" href="ARIADNE_Logo.png">
  <style>
    :root {
        --screen-width: 0px;
        --screen-height: 0px;
    }
    #cy {
        width: var(--screen-width);
        height: var(--screen-height);
        left: 25px;
        /* width: 80vw;
        height: 80vh; */
        /* position: absolute; */
        /* display: block; */
    }
    .custom-tooltip {
        font-family: Helvetica;
        position: absolute;
        background-color: #f1f1f1;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        z-index: 999; /* Ensure the tooltip appears above other elements */
    }
    .info-box {
        font-family: Helvetica;
        position: absolute;
        top: 10px;
        right: 10px;
        width: 300px;
        background-color: #ffffff;
        border: 1px solid #cccccc;
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0px 0px 10px 0px rgba(0,0,0,0.2);
        cursor: pointer;
    }
    .info-box.show {
        display: none;
    }
    body {
        margin: 0;
        padding: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-image: url('ARIADNE_Logo.png');
        background-size: 300px 300px;
        background-repeat: no-repeat;
        background-position: center center;
        /* position: relative; */
    }
    .back-button {
        position: fixed;
        top: 20px; /* Adjust the top distance from the top of the screen */
        left: 20px; /* Adjust the left distance from the left side of the screen */
        z-index: 9999; /* Ensure the button appears above other elements */
        font-size: 24px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    .back-button:hover {
        background-color: #45a049;
    }
    .osf-button {
        position: fixed;
        top: 100px; /* Adjust the top distance from the top of the screen */
        left: 20px; /* Adjust the left distance from the left side of the screen */
        z-index: 9999; /* Ensure the button appears above other elements */
        font-size: 16.5px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    .osf-button:hover {
        background-color: #45a049;
    }
    /*suggestion buttons*/
    .sugg-ghub-button {  /*change the name to gdrive & ghub*/
        position: absolute;
        bottom: 10px; /* Adjust the top distance from the top of the screen */
        left: 20px; /* Adjust the left distance from the left side of the screen */
        z-index: 9999; /* Ensure the button appears above other elements */
        font-size: 16px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    .sugg-ghub-button:hover {
        background-color: #45a049;
    }
    .sugg-gdrive-button { /*change the name to gdrive & ghub*/
        position: absolute;
        bottom: 50px; /* Adjust the top distance from the top of the screen */
        left: 20px; /* Adjust the left distance from the left side of the screen */
        z-index: 9999; /* Ensure the button appears above other elements */
        font-size: 16px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    .sugg-gdrive-button:hover {
        background-color: #45a049;
    }
    /*bug buttons*/
    .bug-ghub-button {  /*change the name to gdrive & ghub*/
        position: absolute;
        bottom: 10px; /* Adjust the top distance from the top of the screen */
        right: 20px; /* Adjust the left distance from the left side of the screen */
        z-index: 9999; /* Ensure the button appears above other elements */
        font-size: 16px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    .bug-ghub-button:hover {
        background-color: #45a049;
    }
    .bug-gdrive-button { /*change the name to gdrive & ghub*/
        position: absolute;
        bottom: 50px; /* Adjust the top distance from the top of the screen */
        right: 20px; /* Adjust the left distance from the left side of the screen */
        z-index: 9999; /* Ensure the button appears above other elements */
        font-size: 16px;
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    .bug-gdrive-button:hover {
        background-color: #45a049;
    }
    /* .bullet-resource { list-style-type: disc; color: #D41159; } */
  </style>
  <script src="./cytoscape/cytoscape.min.js"></script>
  
</head>
<body>
    <button id="back-button" class="back-button" title="Jump back to ARIADNE-Book">←<br>Back to ARIADNE Book</button>
    <button id="osf-button" class="osf-button" title="Jump to OSF repository to see the complete resource table">←<br>Jump to OSF repository<br>to see the complete resource table</button>
    <button id="sugg-gdrive-button" class="sugg-gdrive-button" title="If you have a new resource to suggest; please report them to us via Google Forms!">Suggest new resource via Google Forms</button>
    <button id="sugg-ghub-button" class="sugg-ghub-button" title="If you have a new resource to suggest; please report them to us via GitHub issues!">Suggest new resource via GitHub</button>
    <button id="bug-gdrive-button" class="bug-gdrive-button" title="If you have a a bug that you have encountered; please report them to us via Google Forms!">Report a bug via Google Forms</button>
    <button id="bug-ghub-button" class="bug-ghub-button" title="If you have a bug that you have encountered; please report them to us via GitHub issues!">Report a bug via GitHub</button>
    <div id="cy"></div>
    <div id="info-box" class="info-box">
        <span id="infoTitle"><h2>Instructions:</h2> Click to hide/unhide the instructions</span>
        <div id="infoContent">
            <ul>
            <li>First things first. This is a "dynamic" network. This means that you can drag the nodes around and zoom in/out to resize the view</li>
            <li>Left click on a node to go to the next levels.</li>
            <li>Right click on anywhere to reset to the initial overview.</li>
            <li>Right click on a node to go back to the previous level in the network.</li>
            <li>Hover on any resource node to reveal the information regarding the node.</li>
            <li>Left click on the resource nodes to go to the respective webpages.</li>
            <li>Drag and drop on the nodes to rearrange the graph</li>
            <li>Here's the explanation of all the shapes, just hover over them to reveal the details:</li>
            <canvas id="shapesCanvas" width="280" height="100"></canvas>
        </div>
        
    </div>
    <script>
        // Get the canvas element
        var canvas = document.getElementById("shapesCanvas");
        var ctx = canvas.getContext("2d");
    
        // Define shapes and their respective popup messages
        var shapes = [
            { x: 0, y: 25, width: 50, height: 50, color: "#005AB5", popupMessage: "Initial node, there are more nodes inside this one!" },
            { x: 175, y: 50, radius: 25, color: "#D41159", popupMessage: "Final node. Click this node to go to the resource's website!" }, 
            { x: 75, y: 25, width: 50, height: 50, color: "#40B0A6", diamond: true, popupMessage: "Decision node, filter the nodes and move deeper!" } 
        ];
    
        // Draw shapes on the canvas
    function drawShapes() {
        shapes.forEach(function (shape) {
            ctx.fillStyle = shape.color;
            if (shape.radius) {
                ctx.beginPath();
                ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
                ctx.fill();
            } else if (shape.diamond) {
                ctx.beginPath();
                ctx.moveTo(shape.x + shape.width / 2, shape.y);
                ctx.lineTo(shape.x + shape.width, shape.y + shape.height / 2);
                ctx.lineTo(shape.x + shape.width / 2, shape.y + shape.height);
                ctx.lineTo(shape.x, shape.y + shape.height / 2);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
            }
        });
    }

    // Draw initial shapes
    drawShapes();

    // Function to show popup message
    function showPopup(message, x, y, c_width, c_height) {
        var popupHeight = 20;
        var padding = 5;

        // Calculate text width
        var textWidth = ctx.measureText(message).width;
        var textHeight = ctx.measureText(message).height;
        // if text overflows
        if (c_width < textWidth){
            popupHeight = 20*2;
            var lines = message.split(/\. /g);
        }
        
        // Calculate popup width based on text width and padding
        var popupWidth = textWidth + 2 * padding;
        // var popupHeight = textHeight + 2 * padding;

        // Calculate popup position
        var popupX = x - popupWidth / 2;
        var popupY = y - popupHeight - padding;
        // Adjust popup position to stay within canvas bounds
        if (popupX < 0) {
            popupX = padding;
        }
        if (popupY < 0) {
            popupY = y + padding;
        }
        
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Draw shapes again
        drawShapes();
        // Draw popup message
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
        ctx.fillStyle = "black";
        ctx.font = '12px Arial';
        if (c_width < textWidth){
            ctx.fillText(lines[0], popupX, popupY + 2*padding);
            ctx.fillText(lines[1], popupX, popupY + popupHeight - padding);
        }else{
            ctx.fillText(message, popupX + padding, popupY + popupHeight - padding);
        }
        
    }

    // Event listener for mouse movement
    canvas.addEventListener("mousemove", function (event) {
        var mouseX = event.clientX - canvas.getBoundingClientRect().left;
        var mouseY = event.clientY - canvas.getBoundingClientRect().top;

        shapes.forEach(function (shape) {
            if (shape.radius) {
                var dx = mouseX - shape.x;
                var dy = mouseY - shape.y;
                var distance = Math.sqrt(dx * dx + dy * dy);
                if (distance <= shape.radius) {
                    showPopup(shape.popupMessage, mouseX, mouseY, canvas.width, canvas.height);
                }
            } else if (shape.diamond) {
                if (mouseX >= shape.x && mouseX <= shape.x + shape.width &&
                    mouseY >= shape.y && mouseY <= shape.y + shape.height) {
                    showPopup(shape.popupMessage, mouseX, mouseY, canvas.width, canvas.height);
                }
            } else {
                if (mouseX >= shape.x && mouseX <= shape.x + shape.width &&
                    mouseY >= shape.y && mouseY <= shape.y + shape.height) {
                    showPopup(shape.popupMessage, mouseX, mouseY, canvas.width, canvas.height);
                }
            }
        });
    });

    // Event listener to clear popup when mouse leaves the canvas
    canvas.addEventListener("mouseleave", function () {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawShapes();
    });
</script>



  <script>// Get the width and height of the screen
        var screenWidth = window.innerWidth*0.8;
        var screenHeight = window.innerHeight;
        // Set CSS variables with screen width and height
        // document.documentElement.style.setProperty('--screen-width', screenWidth + 'px');
        // document.documentElement.style.setProperty('--screen-height', screenHeight*0.8 + 'px');
        document.documentElement.style.setProperty('--screen-width', screenWidth+ 'px');
        document.documentElement.style.setProperty('--screen-height', screenHeight + 'px');
        // Also the size of the info box
        function updateInfoBoxSize() {
            screenWidth = window.innerWidth;
            var infoBox = document.getElementById('info-box');
            // Adjust the width of the info box based on the screen width
            infoBox.style.width = screenWidth >= 768 ? '300px' : '150px';
            // You can add additional size adjustments based on screen width if needed
        }
        // Call the function when the window is resized
        window.addEventListener('resize', updateInfoBoxSize);
        // Get the button element
        var redirectToMainButton = document.getElementById('back-button');
        // Add a click event listener to the button
        redirectToMainButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.location.href = 'https://igor-biodgps.github.io/ARIADNE/contentpages/intro.html';
        });
        // jump to osf button
        var redirectToOsfButton = document.getElementById('osf-button');
        // Add a click event listener to the button
        redirectToOsfButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://osf.io/tqjh8/', '_blank');
            // window.location.href = 'https://osf.io/tqjh8/';
        });
        // suggestion buttons
        // Get the button element
        var redirectGhubButton = document.getElementById('sugg-ghub-button');
        // Add a click event listener to the button
        redirectGhubButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://github.com/IGOR-bioDGPs/ARIADNE/issues/new?assignees=&labels=new+resource&projects=&template=resource-submission-form.md&title=', '_blank');
        });
        // Get the button element
        var redirectGDriveButton = document.getElementById('sugg-gdrive-button');
        // Add a click event listener to the button
        redirectGDriveButton.addEventListener('click', function() {
            // Open the desired webpage in a new tab
            window.open('https://docs.google.com/forms/d/1Xqk6MyLYvjdu9cbs1-R40hn9mIZ6KtKL-4LcpI80I_I/', '_blank');
        });
        // now the bug report buttons
        // Get the button element
        var redirectGhubButton = document.getElementById('bug-ghub-button');
        // Add a click event listener to the button
        redirectGhubButton.addEventListener('click', function() {
            // Redirect the user to the desired webpage
            window.open('https://github.com/IGOR-bioDGPs/ARIADNE/issues/new?assignees=&labels=&projects=&template=bug_report.md&title=', '_blank');
        });
        // Get the button element
        var redirectGDriveButton = document.getElementById('bug-gdrive-button');
        // Add a click event listener to the button
        redirectGDriveButton.addEventListener('click', function() {
            // Open the desired webpage in a new tab
            window.open('https://docs.google.com/forms/d/1sCcvmlokUuWc4EG5mz0vXx-QRkyfqN69ibK5b3PqArA/', '_blank');
        });
        // Add a click event listener to the info-box
        var infoBox = document.getElementById('info-box');
        var infoContent = document.getElementById('infoContent');
        infoBox.addEventListener('click', function() {
            infoContent.toggleAttribute("hidden");
        });
    </script>
    <script>
        // async function to get nodes from the Github repo
        async function fetchDataNodes() {
            try {
                const githubRawURL = 'https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/ariadne/data/data_ariadne_nodes.csv';
                const response = await fetch(githubRawURL); // fetch the CSV data from the URL
                const csvData = await response.text(); // and get the response as a text file
                const rows = csvData.split('\n'); // rows are splitted with '/n'
                const nodes = rows.map(row => {
                    // A split the columns into a looong array of variables
                    // Also columns are splitted with ';'
                    const [id, label, shape, bgColor, fontColor, rank, subgraph, mainGraph, isTerminal, href, tooltip, descr] = row.split(';');
                    // And initalise the data structure of the nodes, with using the CSV file and variables
                    return {
                        data: {
                        id: id,
                        label: label,
                        shape: shape,
                        background_color: bgColor,
                        font_color: fontColor,
                        rank: rank,
                        subgraph: subgraph,
                        mainGraph: mainGraph,
                        is_terminal: isTerminal,
                        href: href,
                        tooltip: tooltip,
                        descr: descr
                        }
                    };
                });
                // Create a nodes variable with a sub structure 
                const nodesArr = {
                    nodes: nodes
                };
                // And return the nodes
                return nodesArr;
            } catch (err) { // catch a possible fetch error here
                console.error('Error fetching data from GitHub:', err);
                return null;
            }
        }
        // async function to get edges from the Github repo
        async function fetchDataEdges() {
            try {
                const githubRawURL = 'https://raw.githubusercontent.com/IGOR-bioDGPs/ARIADNE/master/ariadne/data/data_ariadne_edges.csv';
                const response = await fetch(githubRawURL); // fetch the CSV data from the URL
                const csvData = await response.text(); // and get the response as a text file
                const rows = csvData.split('\n'); // rows are splitted with '/n'
                const edges = rows.map(row => {
                    // A split the columns into a looong array of variables
                    // Also columns are splitted with ';'
                    const [id, source, target, subgraph, label, bgColor] = row.split(';');
                    // And initalise the data structure of the nodes, with using the CSV file and variables
                    return {
                        data: {
                        id: id,
                        source: source,
                        target: target,
                        background_color: bgColor,
                        subgraph: subgraph,
                        label: label,
                        }
                    };
                });
                // Create an edges variable with a sub structure 
                const edgesArr = {
                    edges: edges
                };
                // And return the nodes
                return edgesArr;
            } catch (err) { // catch a possible fetch error here
                console.error('Error fetching data from GitHub:', err);
                return null;
            }
        }
        // index variable for keeping track of the first run or others
        let index = 0;
        // get previous subgraph
        let graphPathArr = [];
        // async function to create and draw the graph
        async function createNetwork(sub_graph = '') {
            // wait for nodes
            const nodesArrayAux = await fetchDataNodes();
            // wait for edges
            const edgesArrayAux = await fetchDataEdges();
            // assign nodes&edges to respective variables
            const nodesArray = nodesArrayAux.nodes;
            const edgesArray = edgesArrayAux.edges;
            // Validate and sanitize IDs in the nodesArray
            nodesArray.forEach(node => {
            if (typeof node.data.id !== 'string' || !node.data.id.trim()) {
                // If the ID is not a valid string or is empty, generate a unique ID
                node.data.id = 'node_' + Math.random().toString(36).substr(2, 9);
            }
            });
            // Validate and sanitize IDs in the edgesArray
            edgesArray.forEach(edge => {
            if (typeof edge.data.id !== 'string' || !edge.data.id.trim()) {
                // If the ID is not a valid string or is empty, generate a unique ID
                edge.data.id = 'node_' + Math.random().toString(36).substr(2, 9);
            }
            });
            graphPathArr.push(sub_graph);
            // filter the nodes&edges wrt. to selected node's subgraph
            const filteredNodes = nodesArray.filter(item => item.data.subgraph === sub_graph);
            const filteredEdges = edgesArray.filter(item => item.data.subgraph === sub_graph);
            // now combine the arrays
            const filteredAll = filteredNodes.concat(filteredEdges);
                // configure the cytoscape graph here
                const cy = cytoscape({
                    container: document.getElementById('cy'), // will be drawn on div tag 'cy'
                    elements: filteredAll, // only the filtered elements
                    style: [ // now construct the style of the nodes and edges from the filtered variables
                        {
                        selector: 'node', // node style
                        style: {
                            'background-color': 'data(background_color)',
                            'shape': 'data(shape)',
                            'label': 'data(label)',
                            'font-size': 24,
                            'text-wrap': 'wrap', // or 'ellipsis' for truncation
                            'text-max-width': 150, // Set the maximum width for wrapped text
                        }
                        },
                        {
                        selector: 'edge', // edge style
                        style: {
                            'width': 2,
                            'font-size': 24,
                            'line-color': '#ccc',
                            'target-arrow-color': '#ccc',
                            'target-arrow-shape': 'triangle',
                            'text-wrap': 'wrap',
                            'text-max-width': 100,
                            'text-wrap': 'wrap',
                            'label': 'data(label)'
                        }
                        }
                    ],
                    layout: { // layout is circular
                        name: 'circle',
                        fit: true, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                    },
                    zoom: 1
                });
                if (sub_graph != 'initial'){
                    var styleOptions = cy.layout({
                        name: 'breadthfirst',
                        fit: true, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                        // avoidOverlapPadding: 20, // extra spacing around nodes when avoidOverlap: true
                        spacingFactor: 1.5,
                    });
                    styleOptions.run();
                }
                if (filteredNodes.length < 3){
                    // Calculate the center of the screen
                    var centerX = screenWidth / 2;
                    var centerY = window.innerHeight / 2;

                    // Calculate the positions for the nodes
                    var positions = {};
                    positions[filteredNodes[0].data.id] = { x: centerX, y: centerY - 25 };
                    positions[filteredNodes[1].data.id] = { x: centerX, y: centerY + 200 };

                    // Define layout options
                    var styleOptions2 = cy.layout({
                        name: 'preset',
                        fit: false, // whether to fit the viewport to the graph
                        avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
                        // avoidOverlapPadding: 20, // extra spacing around nodes when avoidOverlap: true
                        // spacingFactor: 1,
                        // zoom: 0.88,
                        // pan: { x: centerX, y: centerY },
                        positions: positions // Assign positions for nodes
                    });
                    styleOptions2.run();
                }
                main(index, cy, graphPathArr); // and now call the main function so we run it indefinitely
                index += 1; // increase the index because we run the code once already
        }
        // main function
        async function main(index, cyto, graphPathArr) {
            // get cyto .css element first
            var cytoCSS = document.body;
            if (index == 0){ // if it's the first iteration
                cyto = await createNetwork('initial'); // draw the initial overview
            }
            else{ // if it's not the first iteration
                // if there is a left click on a node
                cyto.on('click', 'node', function(event) {
                    cytoCSS.style.backgroundImage = 'url("")'; // remove background image
                    var node = event.target; // get the node
                    if (node.data('is_terminal') == 'no'){ // if it's not a terminal node
                        createNetwork(node.data('id').replaceAll(' ','')); // and give it to the network function as 'subgraph'
                    }
                    else{ // if it's a terminal node
                        window.open(node.data('tooltip'), '_blank'); // redirect to the respective webpage
                    }
                });
                // if there is a right click anywhere
                cyto.on('cxttap', function(event) {
                    cytoCSS.style.backgroundImage = 'url("ARIADNE_Logo.png")'; // add background image
                    const tooltips = document.querySelectorAll('.custom-tooltip'); // get all tooltips, i.e. boxes
                    tooltips.forEach(tooltip => tooltip.remove()); // and remove all of them
                    createNetwork('initial'); // and reset to the initial overview
                });
                // if there is a right click on a node
                cyto.on('cxttap', 'node', function(event) {
                    var auxElem = graphPathArr[index-1]; // get the previous subgraph
                    if (auxElem != 'initial'){
                        cytoCSS.style.backgroundImage = 'url("")'; // add background image
                    }
                    createNetwork(auxElem.replace(' ','')); // and reset to the initial overview
                });
                // if there mouse is on a node
                cyto.on('mouseover', 'node', function(event) {
                    const node = event.target;
                    if (node.data('is_terminal') == 'yes'){ // and it's a terminal node
                        var tooltip = document.createElement('div'); // create a tooltip div tag
                        tooltip.className = 'custom-tooltip'; // using the respective CSS 
                        tooltip.textContent = node.data('descr'); // and show the descriptions of the nodes
                        document.body.appendChild(tooltip); // and append to the div tag created
                        // Position the tooltip relative to the node's position and dimensions
                        const nodePosition = node.renderedPosition(); // node's position
                        const nodeHeight = node.height(); // node's height
                        const nodeWidth = node.width(); // node's width
                        tooltip.style.left = nodePosition.x + 'px'; // distance from left
                        tooltip.style.top = nodePosition.y + nodeHeight + 10 + 'px'; // distance from top
                    }
                });
                // if the mouse is moved outside of a node
                cyto.on('mouseout', 'node', function() {
                    const tooltips = document.querySelectorAll('.custom-tooltip'); // get all the boxes
                    tooltips.forEach(tooltip => tooltip.remove()); // and remove them
                });
                // also we want to lock the amount of zoom
                const minZoom = 0.8; // minimum allowed zoom level
                const maxZoom = 1.2; // maximum allowed zoom level
                cyto.on('zoom', function(event) { // handle the zooming part
                    const currentZoom = cyto.zoom();
                    // limit the zoom level to the specified range
                    if (currentZoom < minZoom) {
                        cyto.zoom(minZoom); // set zoom to the minimum value
                    } else if (currentZoom > maxZoom) {
                        cyto.zoom(maxZoom); // set zoom to the maximum value
                    }
                    cyto.center(); // center the whole graph to viewport 
                });
            }
        }
        main(index);
  </script>
</body>
</html>